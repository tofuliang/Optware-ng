diff -dupr a/lib/math.in.h b/lib/math.in.h
--- a/lib/math.in.h	2015-02-10 12:22:33.000000000 +0000
+++ b/lib/math.in.h	2017-10-01 21:16:01.257804603 +0000
@@ -2206,24 +2206,24 @@ _GL_WARN_REAL_FLOATING_DECL (isnan);
 
 #if @GNULIB_SIGNBIT@
 # if @REPLACE_SIGNBIT_USING_GCC@
-#  undef signbit
-   /* GCC 4.0 and newer provides three built-ins for signbit.  */
-#  define signbit(x) \
+#  undef _signbit
+   /* GCC 4.0 and newer provides three built-ins for _signbit.  */
+#  define _signbit(x) \
    (sizeof (x) == sizeof (long double) ? __builtin_signbitl (x) : \
     sizeof (x) == sizeof (double) ? __builtin_signbit (x) : \
     __builtin_signbitf (x))
 # endif
 # if @REPLACE_SIGNBIT@
-#  undef signbit
-_GL_EXTERN_C int gl_signbitf (float arg);
-_GL_EXTERN_C int gl_signbitd (double arg);
-_GL_EXTERN_C int gl_signbitl (long double arg);
+#  undef _signbit
+_GL_EXTERN_C int gl__signbitf (float arg);
+_GL_EXTERN_C int gl__signbitd (double arg);
+_GL_EXTERN_C int gl__signbitl (long double arg);
 #  if __GNUC__ >= 2 && !defined __STRICT_ANSI__
 #   define _GL_NUM_UINT_WORDS(type) \
       ((sizeof (type) + sizeof (unsigned int) - 1) / sizeof (unsigned int))
-#   if defined FLT_SIGNBIT_WORD && defined FLT_SIGNBIT_BIT && !defined gl_signbitf
-#    define gl_signbitf_OPTIMIZED_MACRO
-#    define gl_signbitf(arg) \
+#   if defined FLT_SIGNBIT_WORD && defined FLT_SIGNBIT_BIT && !defined gl__signbitf
+#    define gl__signbitf_OPTIMIZED_MACRO
+#    define gl__signbitf(arg) \
        ({ union { float _value;                                         \
                   unsigned int _word[_GL_NUM_UINT_WORDS (float)];       \
                 } _m;                                                   \
@@ -2231,9 +2231,9 @@ _GL_EXTERN_C int gl_signbitl (long doubl
           (_m._word[FLT_SIGNBIT_WORD] >> FLT_SIGNBIT_BIT) & 1;          \
         })
 #   endif
-#   if defined DBL_SIGNBIT_WORD && defined DBL_SIGNBIT_BIT && !defined gl_signbitd
-#    define gl_signbitd_OPTIMIZED_MACRO
-#    define gl_signbitd(arg) \
+#   if defined DBL_SIGNBIT_WORD && defined DBL_SIGNBIT_BIT && !defined gl__signbitd
+#    define gl__signbitd_OPTIMIZED_MACRO
+#    define gl__signbitd(arg) \
        ({ union { double _value;                                        \
                   unsigned int _word[_GL_NUM_UINT_WORDS (double)];      \
                 } _m;                                                   \
@@ -2241,9 +2241,9 @@ _GL_EXTERN_C int gl_signbitl (long doubl
           (_m._word[DBL_SIGNBIT_WORD] >> DBL_SIGNBIT_BIT) & 1;          \
         })
 #   endif
-#   if defined LDBL_SIGNBIT_WORD && defined LDBL_SIGNBIT_BIT && !defined gl_signbitl
-#    define gl_signbitl_OPTIMIZED_MACRO
-#    define gl_signbitl(arg) \
+#   if defined LDBL_SIGNBIT_WORD && defined LDBL_SIGNBIT_BIT && !defined gl__signbitl
+#    define gl__signbitl_OPTIMIZED_MACRO
+#    define gl__signbitl(arg) \
        ({ union { long double _value;                                   \
                   unsigned int _word[_GL_NUM_UINT_WORDS (long double)]; \
                 } _m;                                                   \
@@ -2252,23 +2252,23 @@ _GL_EXTERN_C int gl_signbitl (long doubl
         })
 #   endif
 #  endif
-#  define signbit(x) \
-   (sizeof (x) == sizeof (long double) ? gl_signbitl (x) : \
-    sizeof (x) == sizeof (double) ? gl_signbitd (x) : \
-    gl_signbitf (x))
+#  define _signbit(x) \
+   (sizeof (x) == sizeof (long double) ? gl__signbitl (x) : \
+    sizeof (x) == sizeof (double) ? gl__signbitd (x) : \
+    gl__signbitf (x))
 # endif
 # ifdef __cplusplus
-#  ifdef signbit
-_GL_MATH_CXX_REAL_FLOATING_DECL_1 (signbit)
-#   undef signbit
-_GL_MATH_CXX_REAL_FLOATING_DECL_2 (signbit)
+#  ifdef _signbit
+_GL_MATH_CXX_REAL_FLOATING_DECL_1 (_signbit)
+#   undef _signbit
+_GL_MATH_CXX_REAL_FLOATING_DECL_2 (_signbit)
 #  endif
 # endif
 #elif defined GNULIB_POSIXCHECK
-# if defined signbit
-_GL_WARN_REAL_FLOATING_DECL (signbit);
-#  undef signbit
-#  define signbit(x) _GL_WARN_REAL_FLOATING_IMPL (signbit, x)
+# if defined _signbit
+_GL_WARN_REAL_FLOATING_DECL (_signbit);
+#  undef _signbit
+#  define _signbit(x) _GL_WARN_REAL_FLOATING_IMPL (_signbit, x)
 # endif
 #endif
 
diff -dupr a/lib/signbitd.c b/lib/signbitd.c
--- a/lib/signbitd.c	2015-02-10 12:22:34.000000000 +0000
+++ b/lib/signbitd.c	2017-10-01 21:15:38.897527753 +0000
@@ -1,4 +1,4 @@
-/* signbit() macro: Determine the sign bit of a floating-point number.
+/* _signbit() macro: Determine the sign bit of a floating-point number.
    Copyright (C) 2007-2015 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
@@ -23,12 +23,12 @@
 #include "isnand-nolibm.h"
 #include "float+.h"
 
-#ifdef gl_signbitd_OPTIMIZED_MACRO
-# undef gl_signbitd
+#ifdef gl__signbitd_OPTIMIZED_MACRO
+# undef gl__signbitd
 #endif
 
 int
-gl_signbitd (double arg)
+gl__signbitd (double arg)
 {
 #if defined DBL_SIGNBIT_WORD && defined DBL_SIGNBIT_BIT
   /* The use of a union to extract the bits of the representation of a
diff -dupr a/lib/signbitf.c b/lib/signbitf.c
--- a/lib/signbitf.c	2015-02-10 12:22:34.000000000 +0000
+++ b/lib/signbitf.c	2017-10-01 21:15:38.805526614 +0000
@@ -1,4 +1,4 @@
-/* signbit() macro: Determine the sign bit of a floating-point number.
+/* _signbit() macro: Determine the sign bit of a floating-point number.
    Copyright (C) 2007, 2009-2015 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
@@ -23,12 +23,12 @@
 #include "isnanf-nolibm.h"
 #include "float+.h"
 
-#ifdef gl_signbitf_OPTIMIZED_MACRO
-# undef gl_signbitf
+#ifdef gl__signbitf_OPTIMIZED_MACRO
+# undef gl__signbitf
 #endif
 
 int
-gl_signbitf (float arg)
+gl__signbitf (float arg)
 {
 #if defined FLT_SIGNBIT_WORD && defined FLT_SIGNBIT_BIT
   /* The use of a union to extract the bits of the representation of a
diff -dupr a/lib/signbitl.c b/lib/signbitl.c
--- a/lib/signbitl.c	2015-02-10 12:22:34.000000000 +0000
+++ b/lib/signbitl.c	2017-10-01 21:15:38.733525722 +0000
@@ -1,4 +1,4 @@
-/* signbit() macro: Determine the sign bit of a floating-point number.
+/* _signbit() macro: Determine the sign bit of a floating-point number.
    Copyright (C) 2007, 2009-2015 Free Software Foundation, Inc.
 
    This program is free software: you can redistribute it and/or modify
@@ -23,12 +23,12 @@
 #include "isnanl-nolibm.h"
 #include "float+.h"
 
-#ifdef gl_signbitl_OPTIMIZED_MACRO
-# undef gl_signbitl
+#ifdef gl__signbitl_OPTIMIZED_MACRO
+# undef gl__signbitl
 #endif
 
 int
-gl_signbitl (long double arg)
+gl__signbitl (long double arg)
 {
 #if defined LDBL_SIGNBIT_WORD && defined LDBL_SIGNBIT_BIT
   /* The use of a union to extract the bits of the representation of a
diff -dupr a/lib/vasnprintf.c b/lib/vasnprintf.c
--- a/lib/vasnprintf.c	2015-03-10 12:20:27.000000000 +0000
+++ b/lib/vasnprintf.c	2017-10-01 21:15:38.861527307 +0000
@@ -3059,7 +3059,7 @@ VASNPRINTF (DCHAR_T *resultbuf, size_t *
 
                         BEGIN_LONG_DOUBLE_ROUNDING ();
 
-                        if (signbit (arg)) /* arg < 0.0L or negative zero */
+                        if (_signbit (arg)) /* arg < 0.0L or negative zero */
                           {
                             sign = -1;
                             arg = -arg;
@@ -3210,7 +3210,7 @@ VASNPRINTF (DCHAR_T *resultbuf, size_t *
                       {
                         int sign = 0;
 
-                        if (signbit (arg)) /* arg < 0.0 or negative zero */
+                        if (_signbit (arg)) /* arg < 0.0 or negative zero */
                           {
                             sign = -1;
                             arg = -arg;
@@ -3606,7 +3606,7 @@ VASNPRINTF (DCHAR_T *resultbuf, size_t *
 
                         BEGIN_LONG_DOUBLE_ROUNDING ();
 
-                        if (signbit (arg)) /* arg < 0.0L or negative zero */
+                        if (_signbit (arg)) /* arg < 0.0L or negative zero */
                           {
                             sign = -1;
                             arg = -arg;
@@ -4071,7 +4071,7 @@ VASNPRINTF (DCHAR_T *resultbuf, size_t *
                       {
                         int sign = 0;
 
-                        if (signbit (arg)) /* arg < 0.0 or negative zero */
+                        if (_signbit (arg)) /* arg < 0.0 or negative zero */
                           {
                             sign = -1;
                             arg = -arg;
diff -dupr a/trio/trio.c b/trio/trio.c
--- a/trio/trio.c	2013-03-19 13:03:43.000000000 +0000
+++ b/trio/trio.c	2017-10-01 21:15:38.965528596 +0000
@@ -2596,7 +2596,7 @@ TRIO_ARGS6((self, number, flags, width,
   assert(((base >= MIN_BASE) && (base <= MAX_BASE)) || (base == NO_BASE));
 
   /* Determine sign and look for special quantities */
-  switch (trio_fpclassify_and_signbit(number, &isNegative))
+  switch (trio_fpclassify_and__signbit(number, &isNegative))
     {
     case TRIO_FP_NAN:
       TrioWriteString(self,
diff -dupr a/trio/trionan.c b/trio/trionan.c
--- a/trio/trionan.c	2013-03-19 13:03:57.000000000 +0000
+++ b/trio/trionan.c	2017-10-01 21:15:38.941528298 +0000
@@ -33,7 +33,7 @@
 
 /*
  * TODO:
- *  o Put all the magic into trio_fpclassify_and_signbit(), and use this from
+ *  o Put all the magic into trio_fpclassify_and__signbit(), and use this from
  *    trio_isnan() etc.
  */
 
@@ -542,16 +542,16 @@ TRIO_ARGS1((number),
  * The sign of NaN is always false
  */
 TRIO_PUBLIC int
-trio_fpclassify_and_signbit
+trio_fpclassify_and__signbit
 TRIO_ARGS2((number, is_negative),
 	   double number,
 	   int *is_negative)
 {
-#if defined(fpclassify) && defined(signbit)
+#if defined(fpclassify) && defined(_signbit)
   /*
-   * C99 defines fpclassify() and signbit() as a macros
+   * C99 defines fpclassify() and _signbit() as a macros
    */
-  *is_negative = signbit(number);
+  *is_negative = _signbit(number);
   switch (fpclassify(number)) {
   case FP_NAN:
     return TRIO_FP_NAN;
@@ -731,13 +731,13 @@ TRIO_ARGS2((number, is_negative),
    sign bit set (i.e. is negative).
 */
 TRIO_PUBLIC int
-trio_signbit
+trio__signbit
 TRIO_ARGS1((number),
 	   double number)
 {
   int is_negative;
   
-  (void)trio_fpclassify_and_signbit(number, &is_negative);
+  (void)trio_fpclassify_and__signbit(number, &is_negative);
   return is_negative;
 }
 
@@ -754,7 +754,7 @@ TRIO_ARGS1((number),
 {
   int dummy;
   
-  return trio_fpclassify_and_signbit(number, &dummy);
+  return trio_fpclassify_and__signbit(number, &dummy);
 }
 
 
@@ -800,7 +800,7 @@ TRIO_ARGS2((prefix, number)
 {
   printf("%-6s: %s %-15s %g\n",
 	 prefix,
-	 trio_signbit(number) ? "-" : "+",
+	 trio__signbit(number) ? "-" : "+",
 	 getClassification(trio_fpclassify(number)),
 	 number);
 }
diff -dupr a/trio/trionan.h b/trio/trionan.h
--- a/trio/trionan.h	2013-03-19 13:03:59.000000000 +0000
+++ b/trio/trionan.h	2017-10-01 21:15:38.941528298 +0000
@@ -68,11 +68,11 @@ TRIO_PUBLIC int trio_isinf TRIO_PROTO((d
  */
 TRIO_PUBLIC int trio_isfinite TRIO_PROTO((double number));
 
-TRIO_PUBLIC int trio_signbit TRIO_PROTO((double number));
+TRIO_PUBLIC int trio__signbit TRIO_PROTO((double number));
 
 TRIO_PUBLIC int trio_fpclassify TRIO_PROTO((double number));
 
-TRIO_PUBLIC int trio_fpclassify_and_signbit TRIO_PROTO((double number, int *is_negative));
+TRIO_PUBLIC int trio_fpclassify_and__signbit TRIO_PROTO((double number, int *is_negative));
 
 #ifdef __cplusplus
 }
